---
title: "08.description_genet.Rmd"
author: "Guillaume Papuga & Eric Imbert"
date: "2025-07-21"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1. Load genetic data

```{r load data}
# Script Eric? 
# Localisation GPS
gps = read.table(here::here ("data", "raw", "genetic", "GENEPOP", "location.csv"), header=T, dec=",")

# Table des pops de Paca
PACA = gps[gps$Longitude>0 & gps$Latitude>42.5,]

# Charge la table des FsT de GENEPOP
#fst = read.table(here::here ("data", "raw", "genetic", "GENEPOP","fst.csv"), header=F) #fst/1-fst from GenepopV4
```

```{r}
# Chargement des donn√©es g√©n√©tiques
df <- read.csv(here::here("data", "processed", "genetic.data.csv"),
               sep = ",", header = TRUE, dec = ".")

# Aper√ßu de la structure des donn√©es
str(df)
head(df)

# √âtape 1 : S√©lection des colonnes de g√©notypes
# On suppose que les g√©notypes sont dans des colonnes nomm√©es "SSR_locus_1", "SSR_locus_2", etc.
geno_cols <- grep("^SSR_", names(df), value = TRUE)  # toutes les colonnes d√©butant par SSR_
geno_data <- df[, geno_cols]

# üßº √âtape 2 : Remplacement des 0 par NA (0 = g√©notype manquant dans ton codage)
geno_data[geno_data == 0] <- NA

# √âtape 3 : Nettoyage des noms de colonnes
# On enl√®ve le pr√©fixe "SSR_" pour plus de clart√©
names(geno_data) <- gsub("^SSR_", "", names(geno_data))

# On force un format standard : locus_1 / locus_2
# Si une colonne se termine par ".1", on la renomme en ".2"
names(geno_data) <- ifelse(grepl("\\.1$", names(geno_data)),
                           gsub("\\.1$", "_2", names(geno_data)),
                           paste0(names(geno_data), "_1"))

# Remplacement final des "." par "_" pour √©viter des erreurs dans les noms de variables
names(geno_data) <- gsub("\\.", "_", names(geno_data))

# √âtape 4 : Identifier les locus (sans suffixe _1/_2)
loci <- unique(sub("_[12]$", "", names(geno_data)))  # ex : "GA12"

# √âtape 5 : Cr√©er une matrice coll√©e all√®le1_all√®le2 par locus (format attendu par df2genind)
geno_collapsed <- sapply(loci, function(locus) {
  paste(geno_data[[paste0(locus, "_1")]],
        geno_data[[paste0(locus, "_2")]],
        sep = "_")
})

# Conversion en data.frame
geno_collapsed <- as.data.frame(geno_collapsed, stringsAsFactors = FALSE)

# √âtape 6 : Conversion en genind
# Variables d'identit√© : noms d‚Äôindividus et populations
genind_obj <- df2genind(geno_collapsed,
                        ploidy = 2,
                        sep = "_",
                        ind.names = df$Accession.N.,  # ou autre identifiant individuel
                        pop = as.factor(df$Pop.N.))   # nom ou code de population

# R√©sum√© de l'objet genind
summary(genind_obj)
```

# 2. Visualisation et description des donn√©es

```{r}
# Aper√ßu des donn√©es (exemple avec un data.frame df)
head(df)

# Distribution spatiale des √©chantillons
ggplot(df, aes(x=longitude, y=latitude)) +
  geom_point(color="blue") +
  coord_fixed() +
  ggtitle("R√©partition spatiale des √©chantillons") +
  theme_minimal()
```
Interpr√©tation :
Cette carte nous donne une id√©e de la couverture g√©ographique des √©chantillons. Une bonne r√©partition est essentielle pour d√©tecter une structure spatiale.


```{r}
# R√©sum√© par locus avec adegenet
locus_summary <- summary(genind_obj)

# On peut extraire par exemple :
locus_summary$loc.n.all   # nombre d'all√®les par locus
locus_summary$Hobs        # h√©t√©rozygotie observ√©e
locus_summary$Hexp        # h√©t√©rozygotie attendue (He)

# Visualisation du nombre d‚Äôall√®les par locus
allele_df <- data.frame(
  locus = names(locus_summary$loc.n.all),
  nb_alleles = locus_summary$loc.n.all
)

ggplot(allele_df, aes(x = reorder(locus, -nb_alleles), y = nb_alleles)) +
  geom_col(fill = "#4472C4") +
  coord_flip() +
  labs(title = "Nombre d'all√®les par locus",
       x = "Locus",
       y = "Nombre d'all√®les") +
  theme_minimal()

```

Interpr√©tation :
Les loci avec peu d‚Äôall√®les (< 3) peuvent √™tre peu informatifs. Des loci tr√®s polymorphes (> 10 all√®les) peuvent avoir un grand pouvoir discriminant, mais parfois aussi plus de bruit ou d‚Äôerreurs de g√©notypage.


```{r}
# library(hierfstat)
# Transformation en objet hierfstat
geno_hierf <- genind2hierfstat(genind_obj)

# Calcul de la richesse all√©lique (nombre moyen d'all√®les par locus)
allelic_richness <- allelic.richness(geno_hierf)

# R√©sultat : tableau avec la richesse all√©lique par population
print(allelic_richness$Ar)

# Visualisation
ar_df <- as.data.frame(allelic_richness$Ar)
ar_df$population <- rownames(ar_df)

ggplot(ar_df, aes(x = reorder(population, -All), y = All)) +
  geom_col(fill = "#2C7BB6") +
  coord_flip() +
  labs(title = "Richesse all√©lique par population",
       x = "Population",
       y = "Richesse all√©lique moyenne") +
  theme_minimal()

```

Interpr√©tation :
La richesse all√©lique refl√®te la diversit√© g√©n√©tique potentielle. Des populations avec une faible richesse peuvent avoir subi une √©rosion g√©n√©tique (ex : goulot d‚Äô√©tranglement), ou √™tre en p√©riph√©rie.

```{r pressure, echo=FALSE, include=FALSE}
summary(genind_obj)  # d√©j√† vu, bon pour inspection rapide

Hs <- Hs(genind_obj)  # diversit√©s g√©n√©tiques intra-population (He)
Ho <- summary(genind_obj)$Hobs  # H√©t√©rozygotie observ√©e
Fis <- inbreeding(genind_obj)  # indice de fixation individuel
```

# 3. Calcul des indices de diversit√© g√©n√©tique par population ou par secteur g√©ographique



```{r}
# Supposons que les colonnes g√©notypes soient en format microsatellite dans un objet genind (adegenet)
# Conversion du dataframe en genind (exemple simplifi√©)
# df_genind <- df2genind(df[,c("locus1", "locus2", ...)], ploidy=2, pop=df$population)

# Indices classiques : He, Ho, nombre d'all√®les
library(hierfstat)
diversity <- basic.stats(df_genind)

# R√©sum√© par population
pop_summary <- data.frame(
  population = rownames(diversity$Hs),
  Ho = diversity$Ho,
  He = diversity$Hs,
  Fis = diversity$Fis
)
print(pop_summary)
```

Interpr√©tation :

    Ho = h√©t√©rozygotie observ√©e

    He = h√©t√©rozygotie attendue (diversit√© g√©n√©tique sous Hardy-Weinberg)

    Fis mesure la consanguinit√©/inbreeding : positive = d√©ficit d'h√©t√©rozygotes.

# 4. Analyse de la structure g√©n√©tique globale

```{r}
# PCA des donn√©es g√©n√©tiques pour visualiser la variation principale
pca <- glPca(df_genind, nf=3)

# Plot PCA
autoplot(pca$scores, data=df, x=1, y=2, colour='population') +
  ggtitle("PCA des profils g√©n√©tiques") +
  theme_minimal()
```

Interpr√©tation :
Les groupes/clusters sur la PCA peuvent refl√©ter des sous-populations g√©n√©tiquement diff√©renci√©es.

# 5. Analyse spatiale de la diversit√© g√©n√©tique
## 5.1 Isolation par la distance (IBD)

```{r}
# Calcul de la matrice g√©n√©tique : distance de Nei
dist_gen <- dist.genpop(df_genind) # si regroup√© par population

# Calcul de la matrice g√©ographique : distances en km
coords <- df %>% distinct(population, longitude, latitude)
dist_geo <- distm(coords[,c("longitude", "latitude")])/1000

# Test Mantel (correlation distance g√©n√©tique - distance g√©ographique)
mantel_test <- mantel(dist_gen, dist_geo, permutations=999)
print(mantel_test)
```

Interpr√©tation :
Un Mantel test significatif indique que la distance g√©n√©tique augmente avec la distance g√©ographique (effet IBD).

# 5.2 Cartographie des indices g√©n√©tiques

```{r}
library(sf)
library(ggspatial)

df_sf <- st_as_sf(df, coords = c("longitude", "latitude"), crs = 4326)

ggplot(df_sf) +
  geom_sf(aes(color = Ho), size = 3) +
  scale_color_viridis_c() +
  ggtitle("Carte de l'h√©t√©rozygotie observ√©e (Ho)") +
  theme_minimal()

Interpr√©tation :
Visualiser la variation spatiale de Ho peut indiquer des zones de forte ou faible diversit√© g√©n√©tique.
Conclusion

Cette analyse exploratoire fournit une premi√®re vision de la diversit√© g√©n√©tique et de sa structuration spatiale, essentielle pour orienter les strat√©gies de conservation et la gestion des populations.

```




